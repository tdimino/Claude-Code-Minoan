<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rocaille Shader - Vanilla WebGL2</title>
    <style>
        * { margin: 0; padding: 0; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        // ============================================
        // CONFIGURATION - Adjust these values
        // ============================================
        const CONFIG = {
            warpCount: 5,      // Number of warp iterations (1-15)
            amplitude: 2.0,    // Warp intensity divisor
            speed: 1.0,        // Animation speed multiplier
            colorMode: 'rainbow' // 'rainbow', 'basic', 'neon', 'fire', 'ocean'
        };

        // Color mode GLSL snippets
        const colorCodes = {
            rainbow: 'vec3 color = 0.5 + 0.5 * cos(atan(v.y, v.x) + vec3(0.0, 2.094, 4.188)); color *= d * 0.15;',
            basic: 'vec3 color = vec3(d * 0.1);',
            neon: 'vec3 color = vec3(d * 0.3, d * 0.05, d * 0.4);',
            fire: 'vec3 color = vec3(d * 0.4, d * 0.15, d * 0.02);',
            ocean: 'vec3 color = vec3(d * 0.02, d * 0.2, d * 0.35);'
        };

        // ============================================
        // WebGL Setup
        // ============================================
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            document.body.innerHTML = '<h1 style="color:white;padding:20px;">WebGL2 not supported</h1>';
            throw new Error('WebGL2 not supported');
        }

        // Vertex shader - full screen quad
        const vertexSource = `#version 300 es
            in vec4 aPosition;
            void main() {
                gl_Position = aPosition;
            }
        `;

        // Fragment shader generator
        function getFragmentSource() {
            return `#version 300 es
                precision highp float;

                uniform float uTime;
                uniform vec2 uResolution;

                out vec4 fragColor;

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution) / uResolution.y;
                    vec2 v = uv;
                    float t = uTime * ${CONFIG.speed.toFixed(1)};

                    // Domain warping loop
                    for(int i = 0; i < ${CONFIG.warpCount}; i++) {
                        v += sin(v.yx + t) / ${CONFIG.amplitude.toFixed(1)};
                    }

                    // Distance field
                    float d = 1.0 / max(length(v), 0.001);

                    // Color mapping
                    ${colorCodes[CONFIG.colorMode]}

                    fragColor = vec4(color, 1.0);
                }
            `;
        }

        // Shader compilation
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Build program
        let program, timeLoc, resolutionLoc;

        function buildProgram() {
            if (program) {
                gl.deleteProgram(program);
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, getFragmentSource());

            program = createProgram(gl, vertexShader, fragmentShader);
            timeLoc = gl.getUniformLocation(program, 'uTime');
            resolutionLoc = gl.getUniformLocation(program, 'uResolution');
        }

        // Geometry - full screen quad (two triangles)
        const positions = new Float32Array([
            -1, -1,  // Bottom left
             1, -1,  // Bottom right
            -1,  1,  // Top left
            -1,  1,  // Top left
             1, -1,  // Bottom right
             1,  1   // Top right
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Vertex array object
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // Initial build
        buildProgram();

        // ============================================
        // Resize handling
        // ============================================
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        window.addEventListener('resize', resize);
        resize();

        // ============================================
        // Render loop
        // ============================================
        function render(time) {
            gl.useProgram(program);
            gl.uniform1f(timeLoc, time * 0.001);
            gl.uniform2f(resolutionLoc, canvas.width, canvas.height);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        // ============================================
        // Configuration helpers (for console use)
        // ============================================
        window.rocaille = {
            setWarpCount: (n) => {
                CONFIG.warpCount = Math.max(1, Math.min(15, n));
                buildProgram();
                console.log('Warp count:', CONFIG.warpCount);
            },
            setAmplitude: (a) => {
                CONFIG.amplitude = Math.max(0.5, Math.min(4.0, a));
                buildProgram();
                console.log('Amplitude:', CONFIG.amplitude);
            },
            setSpeed: (s) => {
                CONFIG.speed = Math.max(0.1, Math.min(3.0, s));
                buildProgram();
                console.log('Speed:', CONFIG.speed);
            },
            setColorMode: (mode) => {
                if (colorCodes[mode]) {
                    CONFIG.colorMode = mode;
                    buildProgram();
                    console.log('Color mode:', CONFIG.colorMode);
                } else {
                    console.log('Available modes:', Object.keys(colorCodes).join(', '));
                }
            },
            getConfig: () => CONFIG
        };

        console.log('Rocaille Shader loaded. Use window.rocaille to configure:');
        console.log('  rocaille.setWarpCount(5)');
        console.log('  rocaille.setAmplitude(2.0)');
        console.log('  rocaille.setSpeed(1.0)');
        console.log('  rocaille.setColorMode("rainbow")');
    </script>
</body>
</html>
