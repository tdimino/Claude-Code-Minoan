# Database Migrations - Official Supabase Documentation

**Source**: Supabase Official Docs + Declarative Schemas Documentation

## Overview

Database migrations are SQL statements that create, update, or delete database schemas. They provide a versioned history of schema changes and ensure consistency across environments.

## Two Approaches to Migrations

### 1. Imperative Migrations (Traditional)

You provide explicit instructions on **how** to change the database.

```sql
-- supabase/migrations/20250101_add_column.sql
ALTER TABLE employees ADD COLUMN department text DEFAULT 'Engineering';
```

**Pros**: Full control, explicit changes
**Cons**: Related info scattered across files, harder to see complete schema

### 2. Declarative Schemas (NEW - Recommended)

You declare the **desired final state** of your database, and migrations are generated automatically.

```sql
-- supabase/schemas/employees.sql
CREATE TABLE employees (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name text NOT NULL,
  email text,
  department text DEFAULT 'Engineering',
  created_at timestamptz DEFAULT now()
);
```

**Pros**: Single source of truth, easier to review, automatic migration generation
**Cons**: Less control over migration steps (but you can always edit generated migrations)

## Declarative Schema Workflow

### Setup

```bash
# Initialize Supabase project
supabase init

# Create schemas directory
mkdir -p supabase/schemas
```

### Create Initial Schema

```sql
-- supabase/schemas/employees.sql
CREATE TABLE employees (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name text NOT NULL,
  email text,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;

-- Create policy
CREATE POLICY "Employees can view all profiles"
ON employees
FOR SELECT
TO authenticated
USING (true);
```

### Generate Migration from Schema

```bash
# Stop local database first (required!)
supabase stop

# Generate migration by diffing schema
supabase db diff -f create_employees_table

# This creates: supabase/migrations/YYYYMMDDHHMMSS_create_employees_table.sql
```

### Apply Migration

```bash
# Start database
supabase start

# Apply migrations
supabase migration up

# View in Dashboard
open http://localhost:54323
```

### Update Schema

```sql
-- supabase/schemas/employees.sql
CREATE TABLE employees (
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name text NOT NULL,
  email text,
  department text DEFAULT 'Engineering',  -- NEW COLUMN
  age smallint,                           -- NEW COLUMN
  created_at timestamptz DEFAULT now()
);

ALTER TABLE employees ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Employees can view all profiles"
ON employees FOR SELECT TO authenticated USING (true);
```

```bash
# Generate migration for changes
supabase db diff -f add_employee_fields

# Apply
supabase migration up
```

## Declarative Schema Organization

### File Naming for Dependencies

Schema files execute in **lexicographic order**. Use prefixes to manage dependencies:

```
supabase/schemas/
├── 01-users.sql          # Create users first
├── 02-organizations.sql  # Organizations reference users
├── 03-posts.sql          # Posts reference organizations
└── 04-comments.sql       # Comments reference posts
```

### Splitting by Entity Type

```
supabase/schemas/
├── tables/
│   ├── users.sql
│   ├── posts.sql
│   └── comments.sql
├── views/
│   └── user_stats.sql
├── functions/
│   └── update_timestamps.sql
└── policies/
    ├── users_policies.sql
    └── posts_policies.sql
```

## Imperative Migration Workflow

### Create Migration

```bash
# Create new migration file
supabase migration new add_posts_table
```

### Write Migration SQL

```sql
-- supabase/migrations/20250101120000_add_posts_table.sql
CREATE TABLE posts (
  id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  user_id uuid REFERENCES auth.users NOT NULL,
  title text NOT NULL,
  content text,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can insert their own posts"
ON posts FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can view all posts"
ON posts FOR SELECT
USING (true);
```

### Apply Migration

```bash
# Apply locally
supabase db reset

# Or apply specific migration
supabase migration up

# Deploy to production
supabase db push
```

## Migration Best Practices

### 1. Small, Focused Migrations

```bash
# ✅ GOOD: One logical change per migration
supabase migration new add_posts_table
supabase migration new add_comments_table

# ❌ BAD: Multiple unrelated changes
supabase migration new add_posts_and_comments_and_likes
```

### 2. Backward Compatible Changes

```sql
-- ✅ GOOD: Add column with default (old code still works)
ALTER TABLE users ADD COLUMN role text DEFAULT 'user';

-- ❌ RISKY: Add NOT NULL column without default (breaks old code)
ALTER TABLE users ADD COLUMN role text NOT NULL;
```

### 3. Test Migrations Locally First

```bash
# Test on local database
supabase db reset

# Verify with seed data
supabase db seed

# Only then push to production
supabase db push
```

### 4. Document Migration Purpose

```sql
-- Migration: Add user roles for RBAC
-- Date: 2025-01-15
-- Author: Engineering Team
-- Ticket: ENG-123

CREATE TYPE user_role AS ENUM ('user', 'admin', 'moderator');

ALTER TABLE users ADD COLUMN role user_role DEFAULT 'user';
```

### 5. Handle Data Migrations Carefully

```sql
-- Step 1: Add new column with default
ALTER TABLE users ADD COLUMN full_name text;

-- Step 2: Migrate existing data
UPDATE users
SET full_name = first_name || ' ' || last_name
WHERE full_name IS NULL;

-- Step 3: Make NOT NULL (in separate migration)
-- ALTER TABLE users ALTER COLUMN full_name SET NOT NULL;
```

## Migration Commands Reference

### Local Development

```bash
# Create new migration
supabase migration new <name>

# Apply all pending migrations
supabase migration up

# Rollback last migration
supabase migration down

# Reset database (drop + recreate + all migrations)
supabase db reset

# Check migration status
supabase migration list

# Generate migration from declarative schema
supabase db diff -f <migration_name>
```

### Production Deployment

```bash
# Push migrations to remote project
supabase db push

# Pull migrations from remote project
supabase db pull

# Link to remote project
supabase link --project-ref <project-id>
```

## Common Migration Patterns

### Adding a Table with RLS

```sql
-- Create table
CREATE TABLE documents (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid REFERENCES auth.users NOT NULL,
  title text NOT NULL,
  content text,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Add policies
CREATE POLICY "Users can view own documents"
ON documents FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own documents"
ON documents FOR INSERT
TO authenticated
WITH CHECK (auth.uid() = user_id);
```

### Adding Foreign Key

```sql
-- Add column first
ALTER TABLE posts ADD COLUMN category_id bigint;

-- Add foreign key
ALTER TABLE posts
ADD CONSTRAINT fk_posts_category
FOREIGN KEY (category_id)
REFERENCES categories(id)
ON DELETE SET NULL;

-- Add index for performance
CREATE INDEX idx_posts_category_id ON posts(category_id);
```

### Creating an Enum Type

```sql
-- Create enum
CREATE TYPE post_status AS ENUM ('draft', 'published', 'archived');

-- Add column using enum
ALTER TABLE posts ADD COLUMN status post_status DEFAULT 'draft';

-- Migrate existing data
UPDATE posts SET status = 'published' WHERE published_at IS NOT NULL;
```

### Adding Triggers

```sql
-- Create trigger function
CREATE OR REPLACE FUNCTION update_modified_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach trigger
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON posts
FOR EACH ROW
EXECUTE FUNCTION update_modified_at();
```

## Declarative Schema Caveats

### Features NOT Supported by `db diff`

Some PostgreSQL features require manual migration creation:

1. **Data migrations** (UPDATE, INSERT, DELETE statements)
2. **Schema renames** (RENAME TABLE, RENAME COLUMN)
3. **Constraint modifications** (changing CHECK constraints)
4. **Extension management** (CREATE EXTENSION)

**Solution**: Create manual migration files for these:

```bash
# Create manual migration
supabase migration new migrate_user_data

# Write custom SQL in the migration file
```

### Handling Renames

```sql
-- ❌ db diff cannot detect renames
-- It sees: DROP old_column + ADD new_column (data loss!)

-- ✅ Manual migration for rename
ALTER TABLE users RENAME COLUMN old_name TO new_name;
```

## Migration Troubleshooting

### Migration Fails on Production

```bash
# Check migration status
supabase db pull

# Test migration locally first
supabase db reset

# If migration is bad, create new migration to fix it
supabase migration new fix_previous_migration
```

### Duplicate Migration Timestamps

```bash
# If you have conflicting timestamps, rename manually
mv supabase/migrations/20250101120000_*.sql \
   supabase/migrations/20250101120001_*.sql
```

### RLS Blocks Migration

```sql
-- Temporarily disable RLS during migration
ALTER TABLE table_name DISABLE ROW LEVEL SECURITY;

-- Run data migration
UPDATE table_name SET ...;

-- Re-enable RLS
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;
```

## Advanced: Branching Workflow

### Create Branch for Testing

```bash
# Create preview branch
supabase branches create feature-branch

# Apply migrations to branch
supabase db push --branch feature-branch

# Test changes on branch
```

### Merge to Production

```bash
# When ready, push to main
supabase db push
```

## Resources

- **Declarative Schemas**: https://supabase.com/docs/guides/local-development/declarative-database-schemas
- **Database Migrations**: https://supabase.com/docs/guides/deployment/database-migrations
- **CLI Reference**: https://supabase.com/docs/reference/cli/supabase-migration
